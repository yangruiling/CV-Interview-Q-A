# 子序列问题 300. 最长上升子序列

Created: March 26, 2023 5:01 PM
Tags: 中等, 动态规划

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：

- 输入：nums = [10,9,2,5,3,7,101,18]
- 输出：4
- 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例 2：

- 输入：nums = [0,1,0,3,2,3]
- 输出：4

示例 3：

- 输入：nums = [7,7,7,7,7,7,7]
- 输出：1

提示：

- 1 <= nums.length <= 2500
- 10^4 <= nums[i] <= 104

解题思路：当前下标i的子序列长度 = i之前下标为j的子序列长度的最大值，考虑使用动态规划解决

动态规划五部曲：

1. 确定dp数组及下标含义，dp[i] = i之前包括i的**以nums[i]结尾**的最长递增子序列长度（只有以nums[i]结尾才能用下一个元素和当前序列作比较）
2. 确定递推式：用j遍历以i之前的每一个数结尾的子序列的最大长度+1，如果nums[i] > nums[j] 最终结果为以i结尾的子序列最大长度和以j结尾的子序列最大长度+1的最大值
    
    if(nums[i] > nums[j]) dp[i] = max(dp[i],dp[j]+1);
    
3. dp数组初始化：以每一个nums[i]元素结尾的序列初始最大长度都为1；
4. 遍历顺序：由递归式可得，nums[i]应该从前向后遍历。i之前的子序列j从前向后或从后向前都可以
5. 打印dp数组

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(), 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
            }
            if (dp[i] > result) result = dp[i]; // 取长的子序列
        }
        return result;
    }
};
```

改进：

1. 最长**连续**递增子**序列长度**: **概括来说：不连续递增子序列的跟前0-i 个状态有关，连续递增的子序列只跟前一个状态有关**
    
    **思路一：**遍历以每一个数值为起始的连续递增子序列，维护一个最大长度变量，不断依据子序列长度更新该变量
    
    **思路二：动态规划**：因为序列连续，所以以当前值为结尾的连续递增子序列只与以前一个值为结尾的连续递增子序列有关
    
    dp[i] = 以i为结尾的连续递增子序列的最大长度，若**nums[i] > nums[i-1]， dp[i] = dp[i-1]+1.**
    

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() == 1) return 1;
        int maxlen = 0;
        for(int i = 0; i< nums.size()-1;i++){
            int len = 1;
            int pre = nums[i];
            for(int j = i+1;j<nums.size();j++){
                if(nums[j]>pre){
                    len++;
                    pre = nums[j];
                }else{
                    break;
                }
            }
            maxlen = max(maxlen,len);
        }
        return maxlen;
    }
};
```

1. 具有**最大和**的**连续子数组（即连续子序列）：从求序列长度变为求序列和，dp[i]只有两种可能性：**

 **初始化dp[0] = nums[0],从前向后遍历**

- dp[i - 1] + nums[i]，即：**nums[i]加入当前连续子序列和**
- nums[i]，即：**从头开始计算当前连续子序列和**
1. 给定**两个数组**，求其公共最长子数组（**公共连续子序列**）
    1. 思路一：暴力求解，使用两层for循环分别遍历两个数组中子序列的所有可能的起始位置，之后再使用一个while或for循环从起始位置开始比较，确定子数组的长度
    2. 动态规划：**用二维数组记录两个字符串的所有比较情况**
    
    动态规划五部曲：
    
    1. 确定dp数组及下标含义，**dp[i][j] = 以下标i-1为结尾的A和以下标j-1为结尾的B，最长重复子数组的长度**（选用i-1的目的是减少初始化的工作量）
    2. 确定递推公式：连续子序列只与前一个元素有关，if(A[i-1] == B[j-1]) dp[i][j] = dp[i-1][j-1]+1;
    3. 初始化dp数组，dp[i][0]与dp[0][i] 都无意义，依据递推公式的需求，初始化为0
    4. 确定遍历顺序，两层for循环分别遍历两个数组，哪个在外层都可以，依据递推公式，遍历时i, j的起始值都为1
    5. 打印dp数组 

```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int result = 0;
        if(nums1 == nums2) return nums1.size();
        for(int i = 0;i < nums1.size();i++){ //数组1起始位置
            for(int j = 0; j<nums2.size();j++){ //数组2起始位置
                int start_i = i;
                int start_j = j;
                int len = 0;
                while(start_i < nums1.size() && start_j < nums2.size() && nums1[start_i] == nums2[start_j]){
                    len++;
                    start_i++;
                    start_j++;
                }
                result = max(result, len);  
            }
        }
        return result;
    }
};
int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp (nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= nums1.size(); i++) {
            for (int j = 1; j <= nums2.size(); j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result) result = dp[i][j];
            }
        }
        return result;
    }
```

1. 求**两个**字符串的最长公共子序列（**不连续，且有相对顺序**）
    
    仍使用二维dp存储两个字符的所有比较情况，区别点
    
    1. 递推公式：由于不连续，存在A[i-1]等于B[j-1]和A[i-1]不等于B[j-1]两种情况
        1. A[i-1]等于B[j-1]，dp[i][j] = dp[i-1][j-1]+1;
        2. A[i-1]不等于B[j-1]，dp[i][j] = dp[i-1][j] 和dp[i][j-1]的最大值
    2. 遍历顺序，由递推公式可知，必须从左到右从上到下依次遍历
2. **判断子序列**：判断B是否是A的子序列  —> **求A，B最长公共子序列的长度，若最终结果=B的长度**，那B是A的子序列
    1. **dp[i][j] 表示以下标i-1为结尾的字符串s（短），和以下标j-1为结尾的字符串t（长），相同子序列的长度为dp[i][j]**
    2. 递推式：
        1. A[i-1]等于B[j-1]，dp[i][j] = dp[i-1][j-1]+1;
        2. A[i-1]不等于B[j-1]，dp[i][j] = dp[i-1][j]，只需要长度长的序列删除元素
    3. 遍历顺序，从上到下从左到右（for循环外层遍历短的序列，内层遍历长的序列）
3. **求在 s （长）的子序列中 t （短）出现的个数**
    
    动态规划五部曲：
    
    1. dp数组及下标的含义，dp[i][j] = 以i-1为结尾的s(长)子序列中出现以j-1为结尾的t（短）的个数为dp[i][j]
    2. 递推公式：
        1. s[i-1]等于t[j-1]，dp[i][j]可以有两部分组成。dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            
            一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1][j-1]。
            
            一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。
            
        
        b. s[i-1]不等于t[j-1]，dp[i][j] = dp[i-1][j]，只需要长度长的序列删除元素
        
    3. 初始化：
        
        **dp[i][0]** 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。那么dp[i][0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是**1**。
        
        **dp[0][j]**：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。那么dp[0][j]一定都是**0**，s如论如何也变成不了t。
        
        **dp[0][0]** 应该是多少。dp[0][0]应该是**1**，空字符串s，可以删除0个元素，变成空字符串t。
        
    4. 遍历顺序：从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算
    5. 打印dp数组
4. **删除元素使两个字符串相同：找到使得 word1 和 word2 相同所需的最小步数**，每步可以删除任意一个字符串中的一个字符 → **求出两个字符串的最长公共子序列长度**即可，那么除了最长公共子序列之外的字符都是必须删除的，最后**用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数**。
5. 摆动序列：求作为**摆动序列的最长子序列长度**（子序列不连续）
    
    动态规划五部曲：
    
    1. dp数组及下标含义: 某个数在摆动序列中可能存在山峰、山谷两种状态
        
        **dp[i][0]**表示以第i个元素为结尾且第i个数作为**山峰**的摆动子序列的最大长度；
        
        **dp[i][1]**表示以第i个元素为结尾且第i个数作为**山谷**的摆动子序列的最大长度；
        
    2. 确定递推公式：用j遍历以i之前的每一个数结尾的摆动子序列的最大长度
        
        若nums[j]为山谷，nums[i]为山峰，即nums[i]>nums[j]，dp[i][0] = max(dp[j][1]+1, dp[i][0])
        
        若nums[j]为山峰，nums[i]为山谷，即nums[i]<nums[j],  dp[i][1] = max(dp[j][1]+1, dp[i][1])
        
    3. 初始化：dp[0][0] = dp[0][1] = dp[i][0] = dp[i][1] = 1，一个元素可作为山峰或山谷
    4. 确定遍历顺序，由递推公式可得从左到右
    5. 打印dp数组